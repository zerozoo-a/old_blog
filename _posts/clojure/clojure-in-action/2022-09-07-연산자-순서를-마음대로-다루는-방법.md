---
layout: post
title: 연산자의 순서를 마음대로 다루는 방법
date: 2022-09-07 01:05 +0900
categories: [clojure-in-action]
---

TOC
---
1. [연산자를 마음대로 다루는 클로져](#연산자를-마음대로-다루는-클로져)
2. [느낀 점](#느낀-점)



## 연산자를 마음대로 다루는 클로져 

클로져의 기능들은 자체적으로 커스텀하기 쉬운 형태로 되어 있는데요

예를 들면 클로져에서 더하기란 이런 식으로 나타냅니다.

```clojure
(+ 1 2) ; => 3
```

보통의 언어들과는 형태가 매우 다릅니다.
이 형태가 이상하다고 생각하실 수 있지만 이 형태는 다른 많은 규칙들을 없애기 위한
단 하나의 규칙이라고 봐도 다르지 않습니다. (개인적 의견입니다.)


이러한 기본적인 클로져의 작동 방식을 다르게 변경하는 것도 가능합니다.
```clojure
(defn r->lfix
      "오른쪽에서 왼쪽의 순서로 연산 한다."
      ([a op b] (op a b))
      ([a op1 b op2 c] (op1 a (op2 b c)))
      ([a op1 b op2 c op3 d] (op1 a (op2 b (op3 c d))))
      )

; (r->lfix 1 + 2 * 4) => 9
; (r->lfix 1 * 2 + 4) => 6 예상한대로의 동작입니다만 받아들이기 불편합니다.
```

이렇게 다루는 것이 가능합니다.
물론 반대 방향도 가능하죠

```clojure
(defn l->rfix
  "왼쪽에서 오른쪽의 순서로 연산 한다."
  ([a op b] (op a b))
  ([a op1 b op2 c] (op2 c (op1 a b)))
  ([a op1 b op2 c op3 d] (op3 d (op2 c (op1 a b))))
  )
; (l->rfix 1 + 2 * 4) => 12
```

이런 방식을 남용하면 혼란만 가져올 수 있겠지만 
이런 식으로 평가를 할 수 있다는 것입니다.

중요한 것은 한 가지입니다. 연산자(함수)를 마음대로 위치시킬 수 있다는 것이죠

위 함수들에서 연산자 우선순위에 맞게 순서를 바르게 고쳐주고 싶다면 아래와 같이 하면 됩니다.


연산자에 우선순위를 두고 이를 매핑하는 방법이 있습니다.

```clojure
(def order {+ 0
            - 0
            * 1
            / 1}) ; 사칙연산의 순서에 따라 부등식을 적용해주면 되겠습니다.

(defn infix3
      "order map에 따라 연산자의 순위를 정해 줍니다.
      예를 들어 (infix3 1 + 2 * 3)처럼 사용한 경우
      (= op1 +) (= op2 *)이므로 부등식이 참이 됩니다.
      곱셈이 뒤에 있으므로 오른쪽부터 연산을 하는 l->rfix 함수를 사용하면 적절히 사용가능합니다."
      [a op1 b op2 c]
      (if (< (get order op1) (get order op2))
        (r->lfix a op1 b op2 c)
        (l->rfix a op1 b op2 c)
        ))
; (infix3 1 + 2 * 4) ; 기댓값 9
; (infix3 1 * 2 + 4) ; 기댓값 6
```

이런식으로 클로져의 강력한 개발자 중심의 확장성을 통해 원하는 코드를 작성 할 수 있다는 것을 살펴보았습니다.



### 느낀 점
이제 슬슬 이번 편을 마쳐야 하는데요.

이번에 clojure in action에서 배운 것은 클로져의 이러한 사용 방법과 매핑 기법입니다.


또한 클로져가 괄호를 통해 c언어에서 부터 파생된 언어들의 연산자 우선순위 규칙을 따르지 않고,


순수히 개발자가 짜놓은 괄호의 안쪽부터 바깥쪽으로 코드가 실행된다는 단순하면서도 명쾌한 규칙이
 있다는 것입니다.




