---
layout: post
title: factorial을 upward로 변경해보기
date: 2022-10-06 23:07 +0900
categories: mjfp
---
알고리즘 문제 풀기 -> factorial upward version
---

현재 공부중인 책에서 나오는 문제를 풀어보며 블로그에 작성해볼까 합니다.
문제는 모두 함수형 패러다임을 따르는 풀이여야만 합니다.

첫 문제는 아래와 같습니다.

### 문제 💁‍♂️
보통의 팩토리얼 알고리즘은 아래와 같다.
인자 즉 조건이 n이고 기저조건은 n이 0일 때이다.

이러한 형태를 보통 downward라고 표현한다.

이를 upward로 변경하라.

```js
function fact(n){
   return n === 0 ? 1 : n * fact(n-1)
}
fact(5) // 120
```

사족: 재귀에 대해 알고계시다면 패스! 🐍🐾
---
전 알고리즘에는 매우 자신이 없는 편이며 실제 실력도 그러합니다. 그런데 함수형으로 문제를 풀라니요..🥲

애초에 위 팩토리얼 알고리즘은 재귀로 작성되어 있어 이미 함수형을 대표하는 알고리즘입니다.


그럼 문제를 잘 활용하면 어쩌면 답이 나올지도 모르겠습니다.


우선 재귀함수에는 여러 중요한 포인트들이 많습니다만 제가 생각하는 가장 중요한 포인트는 기저조건입니다.

그 다음으로는 인자 그리고 반환값이죠
사실 함수에서 중요한 것은 다 말했네요.


upward를 작성하기 전에 downward를 좀 더 알고가면 좋겠습니다.


위 함수가 어떻게 작동될까요?

전 재귀함수가 나올 경우 대입할 수 있는 작으면서도 & 유의미한 값을 대입해보곤합니다.

예를 들어 3이 좋겠네요

```js
fact(3) // expected number is 6
```
6이라는 숫자는 어떻게 나오는 걸까요?

처음 재귀 함수가 작동하고 컴퓨터는 아마 이 지점까지는 무리없이 코드를 읽어내려 갈 것입니다.

`3 * fact(3-1)` 컴퓨터는 코드를 다 읽고 해석하는 와중에 함수 호출이 있다는 것을 알고
처음 재귀 함수가 작동되던 부분을 `기억`합니다. 그리곤 `대기`하도록 합니다. (새로운 콜스택이 쌓인것이지만 이해를 위해)

두 번째의 재귀 함수가 시작됩니다 함수는 비슷하게 다음 코드에서 작동을 멈추고 생각합니다.
`2 * fact(2-1)` 마찬가지로 위와 비슷하게 작동합니다. `기억`하고 `대기`합니다.

세 번째의 재귀 함수도 위와 마찬가지입니다. `1 * fact(1-1)`에서 `기억`과 `대기`를 합니다.

마지막 재귀함수는 다른 곳에서 멈추게 됩니다.
`0 === 0 ? 1 ...` 재귀함수는 드디어 기저조건에 닿았습니다. 이제 재귀함수는 세 번째의 `기억`해 둔 함수에 값을 반환합니다.

`1 * fact(1-1)`은 값을 `대기`하고 있다가 마지막 재귀함수가 반환해준 값을 받습니다.
반환받은 값은 1이네요 이제 대입해봅시다. `1 * 1`

이제 다시 `대기`하고 있는 두 번째 재귀함수에게 값을 돌려주고 그 다음은 가장 처음에 대기하고 있던 함수에게 값을 돌려주게 됩니다.



이제 downward를 잘 파악한 것 같습니다.

풀이 🕵️‍♂️
---
본론으로 다시 돌아가면 upward버전을 작성할 때 중요한 어떻게 기저조건을 세울 것인가? 입니다.

downward는 명백히 0인 경우에 대한 기저조건이 있습니다. upward는 어떤게 기저조건이 되면 좋을까요?

바로 입력받는 값이 기저조건이 되면 가장 좋습니다. 당연히도 0과 반대인 녀석이 가장 좋을것입니다.



재귀호출에서 1 부터 값을 증가시키면서 인자로 넘긴다. 라는 조건이 생겼네요

재귀호출을 해야하니 외부에 변수를 만드는 일은 없어야 합니다. 따라서 기저조건인 입력받은 값을 
다음 재귀호출에게도 알려주어야 기저조건을 발동시킬 수 있을 것입니다.

그렇다면 기저조건 또한 인자로써 넘긴다라는 조건이 필요해집니다.

자 마지막으로 팩토리얼 자체는 1 부터 시작하는 순열입니다. 시작값은 1 부터 시작하면 됩니다.

모든 조건들이 다 정의된 것 같네요.

풀이 코드 👏
---
```js
function fact(n,m=1) {
    return n === m ? n : m * fact(n,m+1)
}
```
자 완성입니다.

인자의 첫 번째는 기저조건을 확인하기 위해 계속 n을 넘겨줍니다.
인자의 두 번째는 값을 늘려주며 기저 조건까지 재귀호출을 반복합니다.

위 코드는 아래처럼 동작할 것입니다.
```js
/** 
 * fact(3)
 * 
 * // => 1 * fact(3, 2)
 *    // => 2 * fact(3, 3)
 *      // => 3
 *          // => 2 * 3
 *              // => 1 * 6
 *                  // => 6
 * */
```
재귀함수의 호출 관계를 글로 작성하려니까 좀 어렵네요..

이렇게 변수를 추가하지 않으면서 문제를 풀어보았습니다.






