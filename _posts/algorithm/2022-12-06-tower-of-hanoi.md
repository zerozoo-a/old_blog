---
layout: post
title: tower-of-hanoi
date: 2022-12-06 02:52 +0900
categories: ["algorithm"]
---

# 하노이의 탑

![tower-of-hanoi 출처 cc: 위키피디아](https://upload.wikimedia.org/wikipedia/commons/thumb/0/07/Tower_of_Hanoi.jpeg/300px-Tower_of_Hanoi.jpeg)


## index 
- [하노이의 탑](#하노이의-탑)
  - [index](#index)
  - [문제](#문제)
  - [풀이](#풀이)
  - [recap](#recap)

---
 
## 문제 
--- 
<br>
<br>

세 개의 기둥이 있으며 각 기둥은 `Start`, `Destination`, `Extra`라는 이름이 있습니다.

각각 `s, d, e`라고 축약합니다.

그리고 n 개의 서로 다른 크기의 원반이 있으며, 이 원반은 어느 기둥에나 꽂을 수 있지만 제약 사항이 있습니다.

1. 한 번에 하나의 원반만을 옮길 수 있습니다.
2. 작은 원반 위에 큰 원반이 위치하도록 옮길 수 없습니다.

n 개의 원반을 인자로 받았을 때, 최소 이동횟수를 반환하세요.

## 풀이 
--- 
<br>
<br>

```js
// node.js
/**
 *
 * @param {char} s
 * @param {char} d
 * @param {char} e
 * @param {number} n
 * @returns
 */
const towerOfHanoi = (s, d, e, n) => {
  if (n <= 0) return;

  towerOfHanoi(s, e, d, n - 1);
  console.log(`원판 ${n}을 ${s}에서 ${d}로 이동합니다.`);
  towerOfHanoi(e, d, s, n - 1);
};
const main = () => {
  towerOfHanoi("s", "d", "e", 3);
};

main();
```

```cpp
// cpp
#include<iostream>

void hanoi(char s, char d, char e, int n) {
    if(n <= 0) return;

    hanoi(s,e,d,n-1);

    std::cout << n << "번 원반을 " << s << "에서 " << d << "로 옮깁니다." << std::endl;

    hanoi(e,d,s,n-1);
}

int main () {

    hanoi('s','d','e',3);

    return 0;
}
```

하노이의 탑이나 피보나치나 모두 점화식을 유도해 문제를 풀게 되는게 보통입니다.
일반해를 구하는 것은 쉽지 않거든요.

아무튼 점화식을 구하는 아이디어는 흔히 말하는 계단 문제와 매우 흡사합니다.
```
P(1) = 1
P(2) = 3
P(3) = 7
...
```
위 함수의 결과값에 대한 수열에서 문제 해결의 힌트를 얻을 수 있습니다.

`P(n) = 2P(n-1) + 1`이라는 식을 얻어내어야 하는데요.
왜 이러한 식이 나오는지 간단한 예제를 살펴보는게 좋겠습니다.

하노이의 탑의 기둥 s, d, e에 n = 3이라는 가정이고, 이는 P(3) 입니다.

s에 3 개의 원판이 있습니다.

원판을 하나씩 옮겨야 하는데요.
그러기엔 너무나도 억울합니다. 왜냐하면 저흰 P(2)의 결과값을 알고 있거든요.
P(2) = 3 입니다. 이 P(2)를 잘 활용해볼 수 없을까요?

> P(2)는 원판 2 개를 원하는 위치에 옮길 때의 최소 이동횟수입니다.

그럼 이걸 d에 바로 옮기는 것은 현명하지 못합니다. 하노이의 탑에 대한 조건에 위배되거든요. 그럼 e에 옮겨봅시다.

`(1): s의 원판 2 개를 e로 옮깁니다. 이 때 필요한 최소 이동 횟수는 P(2)입니다.`

이제 s에는 1 개의 원판, e에는 2 개의 원판, d에는 원판이 없습니다.

`(2): s의 가장 큰 원판을 d에 옮깁니다.`

이제 다시 P(2)의 이동 횟수를 사용하여 e에 있는 원판 2 개를 d로 이동합시다.

`(3): e의 원판 2 개를 P(2)만큼의 이동횟수를 사용하여 d로 옮깁니다.`

이제 s에는 0 개, d에는 3 개, e에는 0 개의 원판이 모였습니다.

모두 옮기는데 성공하였고 이제 갯수를 세어보면

`(1): 3 번, (2): 1 번(3): 3 번`이므로 총 7 번입니다.


(1), (3)은 P(2)를 똑같이 사용하였으므로 `2P(2)`라고 할 수 있겠고,
(2)는 1 번 이동 한 것이니 1 이라고 하면 되겠네요

이제 식이 정확히 이해가 될 것입니다. `tower_of_hanoi: 2P(n-1)+1`




## recap 
--- 
<br>
<br>

문제를 이해하고 이를 점화식이라고 재정의하는 것에 시간이 오래 걸린 것 같습니다.

재귀 함수는 보통 이런식이라는 것을 배웠음에도 불구하고 말이지요.