---
layout: post
title: bubble sort node js
date: 2022-11-14 00:56 +0900
categories: ["algorithm"]
tags: ["bubble sort","sort"]
---


## bubble sort
---
아래의 구현은 그냥 제 생각나는 대로 마구 구현을 한 것이라. 일반적으로 웹에 나와있는
정석 구현과는 많이 다릅니다.

따라서 어차피 안좋은 속도가 좀 더 안좋을 수 있습니다.

```js
/**
 * @description
 *
 * bubbleSort 🫧 의 방식은 두 중첩된 반복문을 통해 이루어진다.
 *
 * 외부의 반복문은 보통 1부터 시작하고 내부의 반복문은 0부터 시작하여 두 인덱스는 각각
 * 배열의 0, 1을 가리킨다.
 *
 * 이 상태로 둘을 비교하여 0 번째 인덱스의 값이 1 번째 인덱스의 값보다 크다면,
 * 서로 스왑한다.
 *
 * 내부의 반복문은 외부의 인덱스보다 적은만큼만 실행하기 때문에 내부의 반복문은 그대로 종료되고
 * 외부의 반복문이 +1 증가하여 내부의 반복문도 바로 이전의 실행보다 +1 번 더 반복하게 된다.
 *
 * 이렇게 외부의 반복문은 내부의 반복문이 종료되는 조건을 제공하면서 외부의 반복문이 n 만큼 증가하면 내부의 반복문은
 * n-1만큼 증가한 형태를 유지한다.
 *
 * [3, 5, 1]을 정렬한다고 가정하면,
 * 외부의 반복문 i(1)는 5를 가리키고
 * 내부의 반복문 j(1)는 3을 가리킨다.
 *
 * 둘은 자리를 바꾸지 않아도 되는 상태이다. 즉 `정렬`되어 있다.
 * 이제 외부의 반복의 인덱스 값을 +1 해주자. i(2)이고 j(0)이다.
 * 바로 j의 인덱스와 i의 인덱스가 가리키는 값 각각 3, 1을 비교한다. 서로 자리를 변경한다.
 * [1, 5, 3]이 된다.
 *
 * 내부 반복문이 깨지지 않았기 때문에 j(1)이 된다. i(2)이제 5 > 3이 성립하므로 다시 스왑한다.
 *
 * [1, 3, 5] 정렬이 되었다.
 *
 * @param {number[]} A
 * @returns {number[]}
 */
exports.bubbleSort = function (A) {
  if (A.length < 2) return A;

  for (let i = 1; i < A.length; i++) {
    for (let j = 0; j < i; j++) {
      if (A[j] > A[i]) {
        [A[j], A[i]] = [A[i], A[j]];
      }
    }
  }

  return A;
};

```